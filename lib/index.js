// Generated by CoffeeScript 1.3.1
var Event, ServerListener, net, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

net = require("net");

Event = require("events").EventEmitter;

_ = require("underscore");

ServerListener = (function(_super) {

  __extends(ServerListener, _super);

  ServerListener.name = 'ServerListener';

  function ServerListener() {
    return ServerListener.__super__.constructor.apply(this, arguments);
  }

  ServerListener.prototype.start = function(port) {
    var self, server;
    if (port == null) {
      port = 25;
    }
    self = this;
    server = net.createServer(function(stream) {
      var stdresponse;
      stream.setEncoding("utf8");
      stream.out = function(msg) {
        return stream.write(msg + '\r\n');
      };
      stdresponse = function() {
        return stream.out('250 nodejs.io');
      };
      stream.isBody = false;
      stream.body = "";
      stream.recipient = "";
      stream.on("connect", function() {
        stream.isBody = false;
        stream.body = "";
        stream.recipient = "";
        return stream.out('220 SMTP nodejs');
      });
      return stream.on("data", function(m) {
        var code, lines;
        code = m.split(" ")[0].match(/.*/)[0];
        if (stream.isBody) {
          lines = _.compact(m.split('\r\n'));
          if (_.last(lines) === ".") {
            stream.isBody = false;
          }
          stream.body += m;
          if (!stream.isBody) {
            self.emit("msg", stream.recipient, stream.body);
          }
        }
        switch (code) {
          case "EHLO":
            return stream.out('502 Unsupported here');
          case "RCPT":
            stream.recipient = m.match(/\<(.*)\>/)[1];
            return stdresponse();
          case "DATA":
            stream.isBody = true;
            return stream.out('354 Enter mail, end with "." on a line by itself');
          case "QUIT":
            stream.out('221 Bye');
            return stream.destroy();
          default:
            return stdresponse();
        }
      });
    });
    server.listen(port);
    return console.log("mail listener has started on port " + port);
  };

  ServerListener.prototype.trim = function(text) {
    return text.replace(/^\s+|\s+$/gi, '');
  };

  ServerListener.prototype.parseBody = function(body) {
    var bodyType, boundary, boundaryTriggered, currentHeader, emailData, headerData, headerMatrix, isContent, self;
    self = this;
    headerMatrix = ["Received", "DKIM-Signature", "MIME-Version", "Received", "Reply-To", "In-Reply-To", "References", "Date", "Message-ID", "Subject", "From", "To", "Cc", "References", "Content-Type", "Content-Transfer-Encoding"];
    emailData = {
      received: [],
      dkim: "",
      mimeVersion: "",
      replyTo: "",
      date: "",
      messageID: "",
      inreplyTo: "",
      references: "",
      subject: "",
      from: "",
      to: "",
      body: {
        plain: "",
        html: ""
      },
      attachment: "COMING SOON"
    };
    headerData = {};
    currentHeader = "";
    isContent = false;
    boundary = "";
    boundaryTriggered = false;
    bodyType = "";
    _.each(body.split("\n"), function(line) {
      var buildFor, content, dataAppend, headerLine, infotype;
      headerLine = line.match(/(^\s?.*)\:\s(.*)/i);
      dataAppend = function() {
        var content;
        content = '\n' + self.trim(line);
        if (isContent) {
          if (boundary !== "" && line === ("--" + boundary)) {
            return boundaryTriggered = true;
          } else if (line !== ("--" + boundary + "--") && bodyType !== "") {
            return emailData.body[bodyType] += content;
          } else {
            return bodyType = "";
          }
        } else {
          switch (currentHeader) {
            case "Received":
              return emailData.received[emailData.received.length - 1] += content;
            case "DKIM-Signature":
              return emailData.dkim += content;
            case "To":
              return emailData.to += content;
            case "Cc":
              return emailData.cc += content;
          }
        }
      };
      if (headerLine != null) {
        if (_.indexOf(headerMatrix, headerLine[1]) !== -1) {
          currentHeader = headerLine[1];
          content = self.trim(headerLine[2]);
          switch (currentHeader) {
            case "Received":
              return emailData.received.push(content);
            case "DKIM-Signature":
              return emailData.dkim = content;
            case "MIME-Version":
              return emailData.mimeVersion = content;
            case "Reply-To":
              return emailData.replyTo = content;
            case "Date":
              return emailData.date = new Date(content);
            case "Message-ID":
              return emailData.messageID = content;
            case "In-Reply-To":
              return emailData.inreplyTo = content;
            case "References":
              return emailData.references = content;
            case "Subject":
              return emailData.subject = content;
            case "From":
              return emailData.from = content;
            case "To":
              return emailData.to = content;
            case "Cc":
              return emailData.cc = content;
            case "Content-Type":
              infotype = content.split(";");
              buildFor = function() {
                console.log(infotype[0]);
                switch (infotype[0]) {
                  case "text/html":
                    return bodyType = "html";
                  case "text/plain":
                    return bodyType = "plain";
                  default:
                    return bodyType = "";
                }
              };
              if (isContent) {
                if (boundaryTriggered) {
                  boundaryTriggered = false;
                  return buildFor();
                }
              } else {
                switch (infotype[0]) {
                  case "multipart/alternative":
                    boundary = infotype[1].match(/.*boundary\=(.*)/i)[1];
                    return isContent = true;
                  case "multipart/related":
                  case "multipart/mixed":
                    return true;
                  default:
                    buildFor();
                    return isContent = true;
                }
              }
          }
        } else {
          return dataAppend();
        }
      } else {
        return dataAppend();
      }
    });
    return emailData;
  };

  return ServerListener;

})(Event);

module.exports = new ServerListener();
